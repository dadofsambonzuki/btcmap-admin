{% extends "base.html" %}

{% block title %}{{ area.tags.get('name', 'Unknown Area') }}{% endblock %}

[Previous content remains exactly the same until line 311...]

async function handleGeoJsonUpdate() {
    const textarea = document.getElementById('geojson-input');
    
    try {
        console.log('Raw textarea value:', textarea.value);

        const validation = validateGeoJson(textarea.value);
        if (!validation.isValid) {
            throw new Error(validation.error);
        }

        const geoJson = validation.data;
        console.log('Parsed GeoJSON:', geoJson);

        const geoJsonString = JSON.stringify(geoJson);
        console.log('Stringified GeoJSON:', geoJsonString);
        
        const requestData = {
            'id': '{{ area.id }}',
            'name': 'geo_json',
            'value': geoJsonString
        };

        console.log('Sending GeoJSON update request:', requestData);

        const geoJsonResponse = await fetch('/api/set_area_tag', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestData)
        });

        if (!geoJsonResponse.ok) {
            const errorData = await geoJsonResponse.json();
            console.error('Server response:', errorData);
            throw new Error(errorData.error?.message || `Server error: ${geoJsonResponse.status}`);
        }

        const geoJsonResult = await geoJsonResponse.json();
        if (geoJsonResult.error) {
            console.error('GeoJSON update error:', geoJsonResult.error);
            throw new Error(geoJsonResult.error?.message || JSON.stringify(geoJsonResult.error));
        }

        const areaKm2 = calculateAreaKm2(geoJson);
        const areaRequestData = {
            'id': '{{ area.id }}',
            'name': 'area_km2',
            'value': areaKm2.toString()
        };

        const areaResponse = await fetch('/api/set_area_tag', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(areaRequestData)
        });

        if (!areaResponse.ok) {
            const errorData = await areaResponse.json();
            console.error('Server response:', errorData);
            throw new Error(errorData.error?.message || `Server error: ${areaResponse.status}`);
        }

        const areaResult = await areaResponse.json();
        if (areaResult.error) {
            console.error('Area update error:', areaResult.error);
            throw new Error(areaResult.error?.message || JSON.stringify(areaResult.error));
        }

        if (!updateMap(geoJson, true)) {
            throw new Error('Failed to update map with new GeoJSON');
        }

        showToast('Success', 'GeoJSON and area updated successfully', 'success');
        hideGeoJsonEditor();
    } catch (error) {
        console.error('Error in GeoJSON update process:', error);
        
        let errorMessage;
        if (error.name === 'TypeError' && error.message.includes('Failed to fetch')) {
            errorMessage = 'Network error: Unable to connect to server';
        } else if (error.message.includes('Server error')) {
            errorMessage = error.message;
        } else {
            errorMessage = error.message || 'Failed to process update';
        }

        showToast('Error', errorMessage, 'error');
    }
}

[Previous content remains exactly the same until line 392...]

function updateOptionalFieldSelect() {
    try {
        const areaType = "{{ area.tags.get('type', '') }}";
        if (!areaType) {
            throw new Error('Area type is not defined');
        }

        const areaTypeRequirements = {{ area_type_requirements | tojson | safe }};
        const typeRequirements = areaTypeRequirements[areaType];
        
        if (!typeRequirements) {
            console.warn(`No requirements found for area type: ${areaType}`);
            const addOptionalTagBtn = document.getElementById('add-optional-tag-btn');
            if (addOptionalTagBtn) {
                addOptionalTagBtn.disabled = true;
            }
            return;
        }

        const existingKeys = getExistingKeys();
        const optionalFields = Object.entries(typeRequirements)
            .filter(([key, req]) => !req.required && !existingKeys.includes(key))
            .map(([key]) => key);

        document.querySelectorAll('.optional-field-select').forEach(select => {
            const currentValue = select.value;
            select.innerHTML = `
                <option value="">Select Optional Field</option>
                ${optionalFields.map(field => 
                    `<option value="${field}" ${currentValue === field ? 'selected' : ''}>${field}</option>`
                ).join('')}
            `;
        });

        const addOptionalTagBtn = document.getElementById('add-optional-tag-btn');
        if (addOptionalTagBtn) {
            addOptionalTagBtn.disabled = optionalFields.length === 0;
        }
    } catch (error) {
        console.error('Error updating optional field select:', error.message || 'Unknown error');
        showToast('Error', error.message || 'Failed to update optional fields', 'error');
    }
}

[Rest of the file remains exactly the same until the end...]