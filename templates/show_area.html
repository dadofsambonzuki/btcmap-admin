{% extends "base.html" %}

{% block title %}{{ area.tags.get('name', 'Unknown Area') }}{% endblock %}

{% block content %}
<!-- [Previous HTML content remains unchanged until line 391] -->
{% raw %}
<script>
// [Previous JavaScript content remains unchanged until handleGeoJsonUpdate function]

async function handleGeoJsonUpdate() {
    const textarea = document.getElementById('geojson-input');
    
    try {
        const validation = validateGeoJson(textarea.value);
        if (!validation.isValid) {
            throw new Error(validation.error);
        }

        const geoJson = validation.data;
        const geoJsonString = JSON.stringify(geoJson);
        
        const requestData = {
            'id': '{{ area.id }}',
            'name': 'geo_json',
            'value': geoJsonString  // Removed single quotes as requested
        };

        console.log('Sending GeoJSON update request:', requestData);

        const geoJsonResponse = await fetch('/api/set_area_tag', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestData)
        });

        let errorData;
        if (!geoJsonResponse.ok) {
            try {
                errorData = await geoJsonResponse.json();
                throw new Error(errorData.error || `Server error: ${geoJsonResponse.status}`);
            } catch (e) {
                throw new Error(`Failed to parse server response: ${e.message}`);
            }
        }

        const geoJsonResult = await geoJsonResponse.json();
        if (geoJsonResult.error) {
            console.error('Server returned error:', geoJsonResult.error);
            throw new Error(typeof geoJsonResult.error === 'string' ? geoJsonResult.error : JSON.stringify(geoJsonResult.error));
        }

        const areaKm2 = calculateAreaKm2(geoJson);
        const areaRequestData = {
            'id': '{{ area.id }}',
            'name': 'area_km2',
            'value': areaKm2.toString()
        };

        const areaResponse = await fetch('/api/set_area_tag', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(areaRequestData)
        });

        if (!areaResponse.ok) {
            try {
                errorData = await areaResponse.json();
                throw new Error(errorData.error || `Server error: ${areaResponse.status}`);
            } catch (e) {
                throw new Error(`Failed to update area: ${e.message}`);
            }
        }

        const areaResult = await areaResponse.json();
        if (areaResult.error) {
            console.error('Server returned error for area update:', areaResult.error);
            throw new Error(typeof areaResult.error === 'string' ? areaResult.error : JSON.stringify(areaResult.error));
        }

        if (!updateMap(geoJson, true)) {
            throw new Error('Failed to update map with new GeoJSON');
        }

        showToast('Success', 'GeoJSON and area updated successfully', 'success');
        hideGeoJsonEditor();
    } catch (error) {
        console.error('Error in GeoJSON update process:', error);
        
        let errorMessage;
        if (error.name === 'TypeError' && error.message.includes('Failed to fetch')) {
            errorMessage = 'Network error: Unable to connect to server';
        } else if (error.message.includes('Server error')) {
            errorMessage = `Server error: ${error.message.split('Server error:')[1].trim()}`;
        } else {
            errorMessage = error.message || 'Failed to process update';
        }

        showToast('Error', errorMessage, 'error');
    }
}

function updateOptionalFieldSelect() {
    try {
        const areaType = "{{ area.tags.get('type', '') }}";
        console.log('Current area type:', areaType);

        if (!areaType) {
            throw new Error('Area type is not defined');
        }

        const areaTypeRequirements = {{ area_type_requirements | tojson | safe }};
        console.log('Area type requirements:', areaTypeRequirements);

        if (!areaTypeRequirements) {
            throw new Error('Area type requirements object is missing');
        }

        if (!areaTypeRequirements[areaType]) {
            throw new Error(`Requirements not found for area type: ${areaType}`);
        }

        const existingKeys = getExistingKeys();
        console.log('Existing keys:', existingKeys);

        const optionalFields = Object.entries(areaTypeRequirements[areaType])
            .filter(([key, req]) => !req.required && !existingKeys.includes(key))
            .map(([key]) => key);

        console.log('Available optional fields:', optionalFields);

        document.querySelectorAll('.optional-field-select').forEach(select => {
            const currentValue = select.value;
            select.innerHTML = `
                <option value="">Select Optional Field</option>
                ${optionalFields.map(field => 
                    `<option value="${field}" ${currentValue === field ? 'selected' : ''}>${field}</option>`
                ).join('')}
            `;
        });

        const addOptionalTagBtn = document.getElementById('add-optional-tag-btn');
        if (addOptionalTagBtn) {
            addOptionalTagBtn.disabled = optionalFields.length === 0;
        }
    } catch (error) {
        console.error('Error updating optional field select:', error);
        showToast('Error', `Failed to update optional fields: ${error.message}`, 'error');
    }
}

// [Rest of the JavaScript code remains unchanged]
</script>
{% endraw %}
{% endblock %}
