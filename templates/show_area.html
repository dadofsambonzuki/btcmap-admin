{% extends "base.html" %}

{% block title %}Show Area{% endblock %}

{% block content %}
<div class="container">
    <h1>Area Details</h1>
    <h2>{{ area.tags.get('name', 'Unnamed Area') }} ({{ area.tags.get('type', 'Unknown Type') }})</h2>

    <!-- Image upload section -->
    <div class="mb-4">
        <h3>Area Icon</h3>
        <div class="image-upload-container">
            <div id="image-preview" class="mb-3" {% if 'icon:square' not in area.tags %}style="display: none;"{% endif %}>
                <img id="preview-img" class="img-fluid" style="max-width: 300px; max-height: 300px;" 
                     src="{{ area.tags.get('icon:square', '') if 'icon:square' in area.tags else '' }}">
            </div>
            <input type="file" id="image-input" class="form-control mb-2" accept="image/png,image/jpeg,image/jpg" style="display: none;">
            <div class="btn-group">
                <button id="upload-image-btn" class="btn btn-primary">Upload Image</button>
                <button id="edit-image-btn" class="btn btn-secondary" {% if 'icon:square' not in area.tags %}style="display: none;"{% endif %}>Edit Image</button>
                <button id="remove-image-btn" class="btn btn-danger" {% if 'icon:square' not in area.tags %}style="display: none;"{% endif %}>Remove</button>
            </div>
            <div class="image-editor" style="display: none;">
                <canvas id="image-canvas"></canvas>
                <div class="btn-group mt-2">
                    <button id="save-image-btn" class="btn btn-success">Update</button>
                    <button id="cancel-image-btn" class="btn btn-secondary">Cancel</button>
                </div>
            </div>
            <small class="text-muted d-block mt-2">
                Supported formats: PNG, JPEG. Image must be square and under 1MB.
            </small>
        </div>
    </div>

    <!-- Map container -->
    <div id="map-container">
        <div id="map"></div>
        <button id="edit-geojson-btn" class="btn btn-primary">Edit GeoJSON</button>
    </div>

    <!-- GeoJSON editor -->
    <div id="geojson-editor" class="mb-3" style="display: none;">
        <textarea id="geojson-input" class="form-control mb-2" rows="5"></textarea>
        <div class="btn-group">
            <button id="show-btn" class="btn btn-primary">Show</button>
            <button id="update-btn" class="btn btn-success">Update</button>
            <button id="cancel-btn" class="btn btn-secondary">Cancel</button>
        </div>
    </div>

    <!-- Area information -->
    <table id="tags-table" class="table table-striped">
        <thead>
            <tr>
                <th>Key</th>
                <th>Value</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody>
            {% for key, requirements in area_type_requirements.items() %}
            <tr data-key="{{ key }}">
                <td>{{ key }}</td>
                <td class="tag-value-cell">
                    <span class="tag-value-content">{{ area.tags.get(key, '') }}</span>
                    {% if requirements.get('allowed_values') %}
                    <select class="form-control tag-select d-none">
                        {% for value in requirements.allowed_values %}
                        <option value="{{ value }}" {% if value == area.tags.get(key) %}selected{% endif %}>{{ value }}</option>
                        {% endfor %}
                    </select>
                    {% else %}
                    <input type="text" class="form-control tag-input d-none" value="{{ area.tags.get(key, '') }}">
                    {% endif %}
                    <div class="invalid-feedback"></div>
                </td>
                <td>
                    <button class="btn btn-primary btn-sm edit-tag">Edit</button>
                    <button class="btn btn-success btn-sm update-tag d-none">Update</button>
                    <button class="btn btn-secondary btn-sm cancel-edit d-none">Cancel</button>
                    {% if not requirements.get('required', False) %}
                    <button class="btn btn-danger btn-sm delete-tag">Remove</button>
                    {% endif %}
                </td>
            </tr>
            {% endfor %}
        </tbody>
    </table>

    <div class="mt-4 danger-zone">
        <h3>Danger Zone</h3>
        <button class="btn btn-danger" onclick="removeArea('{{ area.id }}')">Remove Area</button>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
<script src="{{ url_for('static', filename='js/validation.js') }}"></script>
<script>
// Global variables
let map;
let geoJsonLayer;
let mapInitialized = false;
const elements = {
    mapContainer: document.getElementById('map'),
    editGeoJsonBtn: document.getElementById('edit-geojson-btn'),
    geoJsonEditor: document.getElementById('geojson-editor'),
    geoJsonInput: document.getElementById('geojson-input'),
    showBtn: document.getElementById('show-btn'),
    updateBtn: document.getElementById('update-btn'),
    cancelBtn: document.getElementById('cancel-btn'),
    tagsTable: document.getElementById('tags-table')
};

// Debug logging function
function logDebug(message, error = null) {
    console.log(`[Debug] ${message}`);
    if (error) {
        console.error('[Error]', error);
    }
}

// Map initialization
function initializeMap() {
    try {
        logDebug('Initializing map...');
        if (!elements.mapContainer) {
            throw new Error('Map container not found');
        }

        map = L.map('map').setView([0, 0], 2);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© OpenStreetMap contributors'
        }).addTo(map);

        const geoJson = {{ geo_json | tojson | safe if geo_json else 'null' }};
        if (geoJson) {
            updateMapWithGeoJson(geoJson);
        }

        mapInitialized = true;
        logDebug('Map initialized successfully');
    } catch (error) {
        logDebug('Failed to initialize map', error);
        showToast('Error', 'Failed to initialize map: ' + error.message, 'error');
    }
}

// Update map with GeoJSON
function updateMapWithGeoJson(geoJson) {
    try {
        logDebug('Updating map with GeoJSON input:', geoJson);

        // Remove existing layer
        if (geoJsonLayer) {
            map.removeLayer(geoJsonLayer);
        }

        // Handle string input
        if (typeof geoJson === 'string') {
            geoJson = JSON.parse(geoJson);
        }

        logDebug('Adding GeoJSON to map:', geoJson);
        geoJsonLayer = L.geoJSON(geoJson).addTo(map);
        map.fitBounds(geoJsonLayer.getBounds());
        logDebug('GeoJSON updated successfully');
        return true;
    } catch (error) {
        logDebug('Failed to update GeoJSON', error);
        showToast('Error', 'Invalid GeoJSON: ' + error.message, 'error');
        return false;
    }
}

// Initialize event listeners
function initializeEventListeners() {
    try {
        logDebug('Initializing event listeners');

        // GeoJSON editor buttons
        if (elements.editGeoJsonBtn) {
            elements.editGeoJsonBtn.addEventListener('click', startGeoJsonEditing);
        }
        if (elements.showBtn) {
            elements.showBtn.addEventListener('click', showGeoJson);
        }
        if (elements.updateBtn) {
            elements.updateBtn.addEventListener('click', updateGeoJson);
        }
        if (elements.cancelBtn) {
            elements.cancelBtn.addEventListener('click', cancelGeoJsonEditing);
        }

        // Tags table event delegation
        if (elements.tagsTable) {
            elements.tagsTable.addEventListener('click', handleTagsTableClick);
        }

        logDebug('Event listeners initialized successfully');
    } catch (error) {
        logDebug('Failed to initialize event listeners', error);
        showToast('Error', 'Failed to initialize event listeners: ' + error.message, 'error');
    }
}

// GeoJSON editing functions
function startGeoJsonEditing() {
    logDebug('Starting GeoJSON editing');
    elements.geoJsonEditor.style.display = 'block';
    const geoJson = geoJsonLayer.toGeoJSON();
    const geometry = geoJson.type === 'FeatureCollection' 
        ? geoJson.features[0].geometry 
        : geoJson.type === 'Feature' 
            ? geoJson.geometry 
            : geoJson;
    elements.geoJsonInput.value = JSON.stringify(geometry, null, 2);
}

function showGeoJson() {
    try {
        const geoJson = JSON.parse(elements.geoJsonInput.value);
        if (updateMapWithGeoJson(geoJson)) {
            showToast('Success', 'GeoJSON preview updated', 'success');
        }
    } catch (error) {
        logDebug('Failed to show GeoJSON', error);
        showToast('Error', 'Invalid GeoJSON: ' + error.message, 'error');
    }
}

function updateGeoJson() {
    try {
        logDebug('Starting GeoJSON update');
        const rawInput = elements.geoJsonInput.value;
        
        // Parse and stringify to remove formatting/whitespace
        const geoJson = JSON.parse(rawInput);
        const cleanGeoJson = JSON.stringify(geoJson);
        
        logDebug('Clean GeoJSON:', cleanGeoJson);

        fetch('/api/set_area_tag', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                id: '{{ area.id }}',
                name: 'geo_json',
                value: cleanGeoJson
            })
        })
        .then(response => {
            if (!response.ok) {
                return response.json().then(data => {
                    throw new Error(data.error || `HTTP error! status: ${response.status}`);
                });
            }
            return response.json();
        })
        .then(data => {
            if (data.error) {
                throw new Error(data.error || 'Failed to update GeoJSON');
            }
            logDebug('GeoJSON successfully updated on server');
            showToast('Success', 'GeoJSON updated successfully', 'success');
            elements.geoJsonEditor.style.display = 'none';
            // Refresh the map with the updated GeoJSON
            updateMapWithGeoJson(geoJson);
        })
        .catch(error => {
            logDebug('Failed to update GeoJSON on server', error);
            showToast('Error', error.message || 'Failed to update GeoJSON', 'error');
        });
    } catch (error) {
        logDebug('Failed to process GeoJSON input', error);
        showToast('Error', 'Invalid GeoJSON: ' + error.message, 'error');
    }
}

function cancelGeoJsonEditing() {
    elements.geoJsonEditor.style.display = 'none';
}

// Tag editing functions
function startEditing(row) {
    logDebug('Starting tag editing');
    const valueCell = row.querySelector('.tag-value-cell');
    const content = valueCell.querySelector('.tag-value-content');
    const input = valueCell.querySelector('.tag-input');
    const select = valueCell.querySelector('.tag-select');
    const editBtn = row.querySelector('.edit-tag');
    const updateBtn = row.querySelector('.update-tag');
    const cancelBtn = row.querySelector('.cancel-edit');

    content.classList.add('d-none');
    if (input) {
        input.classList.remove('d-none');
        input.value = content.textContent.trim();
    }
    if (select) {
        select.classList.remove('d-none');
    }
    editBtn.classList.add('d-none');
    updateBtn.classList.remove('d-none');
    cancelBtn.classList.remove('d-none');
}

function updateTag(row) {
    logDebug('Updating tag');
    const key = row.dataset.key;
    const valueCell = row.querySelector('.tag-value-cell');
    const input = valueCell.querySelector('.tag-input');
    const select = valueCell.querySelector('.tag-select');
    const content = valueCell.querySelector('.tag-value-content');

    let value = (input && !input.classList.contains('d-none')) ? input.value :
                (select && !select.classList.contains('d-none')) ? select.value :
                content.textContent;

    // Validate the value
    const requirements = {{ area_type_requirements | tojson | safe }}[key] || {};
    let validation;
    if (requirements.type === 'number' || requirements.type === 'integer') {
        validation = validateNumericValue(value, requirements.type);
    } else {
        validation = validateValue(value, requirements);
    }

    if (!validation.isValid) {
        showToast('Error', validation.message, 'error');
        return;
    }

    fetch('/api/set_area_tag', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            id: '{{ area.id }}',
            name: key,
            value: validation.value
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.error) {
            throw new Error(data.error.message || 'Failed to update tag');
        }
        content.textContent = validation.value;
        cancelEditing(row);
        showToast('Success', 'Tag updated successfully', 'success');
    })
    .catch(error => {
        logDebug('Failed to update tag', error);
        showToast('Error', error.message, 'error');
    });
}

function cancelEditing(row) {
    logDebug('Canceling tag editing');
    const valueCell = row.querySelector('.tag-value-cell');
    const content = valueCell.querySelector('.tag-value-content');
    const input = valueCell.querySelector('.tag-input');
    const select = valueCell.querySelector('.tag-select');
    const editBtn = row.querySelector('.edit-tag');
    const updateBtn = row.querySelector('.update-tag');
    const cancelBtn = row.querySelector('.cancel-edit');

    content.classList.remove('d-none');
    if (input) input.classList.add('d-none');
    if (select) select.classList.add('d-none');
    editBtn.classList.remove('d-none');
    updateBtn.classList.add('d-none');
    cancelBtn.classList.add('d-none');

    // Reset validation state
    if (input) {
        input.classList.remove('is-invalid');
        const feedback = valueCell.querySelector('.invalid-feedback');
        if (feedback) {
            feedback.style.display = 'none';
        }
    }
}

function handleTagsTableClick(e) {
    const target = e.target;
    if (!target.matches('button')) return;
    
    const row = target.closest('tr');
    if (!row) return;

    if (target.classList.contains('edit-tag')) {
        startEditing(row);
    } else if (target.classList.contains('update-tag')) {
        updateTag(row);
    } else if (target.classList.contains('cancel-edit')) {
        cancelEditing(row);
    } else if (target.classList.contains('delete-tag')) {
        const key = row.dataset.key;
        showToast(
            'Confirm Delete',
            `Are you sure you want to remove the tag "${key}"?`,
            'warning',
            {
                confirmButtonText: 'Yes, delete it',
                cancelButtonText: 'Cancel',
                onConfirm: () => removeTag('{{ area.id }}', key)
            }
        );
    }
}

// Initialize everything after DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    logDebug('DOM loaded, starting initialization');
    initializeEventListeners();
});

// Initialize map after all resources are loaded
window.addEventListener('load', () => {
    logDebug('Window loaded, initializing map');
    initializeMap();
});

// Handle visibility change
document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        logDebug('Page hidden, cleaning up map');
        if (map) {
            map.remove();
            map = null;
            mapInitialized = false;
        }
    } else if (!mapInitialized) {
        logDebug('Page visible, reinitializing map');
        initializeMap();
    }
});

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
    logDebug('Page unloading, cleaning up map');
    if (map) {
        map.remove();
        map = null;
        mapInitialized = false;
    }
});

// Image handling
const imageElements = {
    input: document.getElementById('image-input'),
    preview: document.getElementById('image-preview'),
    previewImg: document.getElementById('preview-img'),
    uploadBtn: document.getElementById('upload-image-btn'),
    editBtn: document.getElementById('edit-image-btn'),
    removeBtn: document.getElementById('remove-image-btn'),
    editor: document.querySelector('.image-editor'),
    canvas: document.getElementById('image-canvas'),
    saveBtn: document.getElementById('save-image-btn'),
    cancelBtn: document.getElementById('cancel-image-btn')
};

let fabricCanvas;
let currentImage = null;

// Initialize fabric canvas
function initializeFabricCanvas() {
    if (fabricCanvas) {
        fabricCanvas.dispose();
    }
    fabricCanvas = new fabric.Canvas('image-canvas', {
        width: 300,
        height: 300
    });
}

// Validate image dimensions and size
function validateImage(file) {
    return new Promise((resolve, reject) => {
        if (file.size > 1024 * 1024) {
            reject('Image size must be less than 1MB');
            return;
        }

        const img = new Image();
        img.onload = () => {
            const aspectRatio = img.width / img.height;
            if (Math.abs(aspectRatio - 1) > 0.01) {
                reject('Image must be square (1:1 aspect ratio)');
                return;
            }
            resolve(img);
        };
        img.onerror = () => reject('Invalid image file');
        img.src = URL.createObjectURL(file);
    });
}

// Convert image to base64
function getBase64Image(img) {
    const canvas = document.createElement('canvas');
    canvas.width = img.width;
    canvas.height = img.height;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0);
    const dataURL = canvas.toDataURL();
    return dataURL.split(',')[1]; // Return only the base64 data
}

// Image upload handling
imageElements.uploadBtn.addEventListener('click', () => {
    imageElements.input.click();
});

imageElements.input.addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    try {
        const img = await validateImage(file);
        const base64Data = getBase64Image(img);
        
        // Update preview
        imageElements.previewImg.src = `data:${file.type};base64,${base64Data}`;
        imageElements.preview.style.display = 'block';
        imageElements.editBtn.style.display = 'inline-block';
        imageElements.removeBtn.style.display = 'inline-block';
        
        // Store current image
        currentImage = {
            base64: base64Data,
            extension: file.name.split('.').pop().toLowerCase()
        };

        // Submit image to server
        updateImage();
    } catch (error) {
        showToast('Error', error, 'error');
        imageElements.input.value = '';
    }
});

// Image editing
imageElements.editBtn.addEventListener('click', () => {
    if (!imageElements.previewImg.src) return;
    
    initializeFabricCanvas();

    fabric.Image.fromURL(imageElements.previewImg.src, (img) => {
        fabricCanvas.clear();
        
        // Scale image to fit canvas
        const scale = Math.min(300 / img.width, 300 / img.height);
        img.scale(scale);
        
        // Center image
        img.set({
            left: (300 - img.width * scale) / 2,
            top: (300 - img.height * scale) / 2
        });
        
        fabricCanvas.add(img);
        fabricCanvas.setActiveObject(img);
        imageElements.editor.style.display = 'block';
    });
});

// Save edited image
imageElements.saveBtn.addEventListener('click', () => {
    if (!fabricCanvas) return;
    
    const dataURL = fabricCanvas.toDataURL({
        format: 'png',
        quality: 0.8
    });
    
    imageElements.previewImg.src = dataURL;
    currentImage = {
        base64: dataURL.split(',')[1],
        extension: 'png'
    };
    imageElements.editor.style.display = 'none';
    
    // Submit updated image to server
    updateImage();
});

// Cancel image editing
imageElements.cancelBtn.addEventListener('click', () => {
    imageElements.editor.style.display = 'none';
});

// Remove image
imageElements.removeBtn.addEventListener('click', () => {
    showToast(
        'Confirm Delete',
        'Are you sure you want to remove the area icon?',
        'warning',
        {
            confirmButtonText: 'Yes, remove it',
            cancelButtonText: 'Cancel',
            onConfirm: () => removeImage()
        }
    );
});

// Update image on server
function updateImage() {
    if (!currentImage) return;

    fetch('/api/set_area_icon', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            id: '{{ area.id }}',
            image: currentImage.base64,
            extension: currentImage.extension
        })
    })
    .then(response => {
        if (!response.ok) {
            return response.json().then(data => {
                throw new Error(data.error || `HTTP error! status: ${response.status}`);
            });
        }
        return response.json();
    })
    .then(data => {
        showToast('Success', 'Image updated successfully', 'success');
    })
    .catch(error => {
        console.error('Error updating image:', error);
        showToast('Error', error.message || 'Failed to update image', 'error');
    });
}

// Remove image from server
function removeImage() {
    fetch('/api/remove_area_tag', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            id: '{{ area.id }}',
            tag: 'icon:square'
        })
    })
    .then(response => {
        if (!response.ok) {
            return response.json().then(data => {
                throw new Error(data.error || `HTTP error! status: ${response.status}`);
            });
        }
        return response.json();
    })
    .then(data => {
        imageElements.preview.style.display = 'none';
        imageElements.editBtn.style.display = 'none';
        imageElements.removeBtn.style.display = 'none';
        imageElements.input.value = '';
        currentImage = null;
        showToast('Success', 'Image removed successfully', 'success');
    })
    .catch(error => {
        console.error('Error removing image:', error);
        showToast('Error', error.message || 'Failed to remove image', 'error');
    });
}
</script>
{% endblock %}