{% extends "base.html" %}

{% block title %}Add Area{% endblock %}

{% block content %}
<div class="container">
    <h1 class="mt-5">Add New Area</h1>
    
    <!-- Map container with Edit GeoJSON button -->
    <div id="map" class="position-relative mb-3" style="height: 400px; width: 100%;">
        <button id="edit-geojson-btn" class="btn btn-primary btn-sm position-absolute" style="top: 10px; right: 10px; z-index: 1000;">Edit GeoJSON</button>
    </div>
    
    <!-- GeoJSON editing section -->
    <div id="geojson-editor" class="mb-3">
        <textarea id="geojson-input" class="form-control mb-2" rows="5" style="display: none;"></textarea>
        <button id="show-btn" class="btn btn-primary" style="display: none;">Show</button>
        <button id="save-locally-btn" class="btn btn-success" style="display: none;">Save Locally</button>
        <button id="cancel-geojson-btn" class="btn btn-secondary" style="display: none;">Cancel</button>
    </div>
    
    <div class="card mt-3">
        <div class="card-body">
            <form id="add-area-form" method="POST">
                <div class="form-group">
                    <label for="type">Area Type</label>
                    <select class="form-control" id="type" name="type" required>
                        <option value="">Select Area Type</option>
                        {% for area_type in area_type_requirements.keys() %}
                        <option value="{{ area_type }}">{{ area_type|capitalize }}</option>
                        {% endfor %}
                    </select>
                </div>
                <table class="table table-striped mt-3" id="tags-table">
                    <thead>
                        <tr>
                            <th>Key</th>
                            <th>Value</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Tags will be dynamically added here -->
                    </tbody>
                </table>
                <div class="mt-3 text-center">
                    <button type="button" id="add-optional-field-btn" class="btn btn-secondary">Add Optional Field</button>
                    <button type="button" id="add-custom-field-btn" class="btn btn-secondary">Add Custom Field</button>
                </div>
            </form>
        </div>
    </div>
    
    <!-- Separate section for Add Area button -->
    <div class="mt-4 text-center">
        <button id="submit-area-btn" class="btn btn-primary btn-lg">Add Area</button>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    const areaTypeRequirements = {{ area_type_requirements | tojson | safe }};
    const typeSelect = document.getElementById('type');
    const tagsTable = document.getElementById('tags-table').querySelector('tbody');
    const addOptionalFieldBtn = document.getElementById('add-optional-field-btn');
    const addCustomFieldBtn = document.getElementById('add-custom-field-btn');
    const form = document.getElementById('add-area-form');
    const submitAreaBtn = document.getElementById('submit-area-btn');

    // Initialize map
    var map = L.map('map').setView([0, 0], 2);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: 'Â© OpenStreetMap contributors'
    }).addTo(map);

    var geoJsonLayer;
    var currentGeoJson;
    var previouslySavedGeoJson;

    function validateKey(key) {
        if (!key || typeof key !== 'string') {
            return { isValid: false, error: "Key must be a non-empty string" };
        }
        
        key = key.trim();
        if (!key) {
            return { isValid: false, error: "Key cannot be empty or contain only whitespace" };
        }
        
        if (!/^[a-zA-Z][a-zA-Z0-9_:]*$/.test(key)) {
            return { isValid: false, error: "Key must start with a letter and contain only letters, numbers, underscores, and colons" };
        }
        
        return { isValid: true, key: key };
    }

    function validateValue(value, type = 'text', allowedValues = null) {
        if (!value || typeof value !== 'string') {
            return { isValid: false, error: "Value must be a non-empty string" };
        }

        value = value.trim();
        if (!value) {
            return { isValid: false, error: "Value cannot be empty or contain only whitespace" };
        }

        if (type === 'number') {
            if (!/^\d*\.?\d+$/.test(value)) {
                return { isValid: false, error: "Value must be a valid number" };
            }
        } else if (type === 'date') {
            if (!/^\d{4}-\d{2}-\d{2}$/.test(value)) {
                return { isValid: false, error: "Value must be in YYYY-MM-DD format" };
            }
        } else if (allowedValues) {
            if (!allowedValues.includes(value)) {
                return { isValid: false, error: `Value must be one of: ${allowedValues.join(', ')}` };
            }
        }

        return { isValid: true, value: value };
    }

    function createTagRow(key, value = '', isRequired = false, isCustom = false, allowedValues = null) {
        const row = document.createElement('tr');
        const keyCell = document.createElement('td');
        const valueCell = document.createElement('td');
        const actionCell = document.createElement('td');

        if (isCustom) {
            const keyInput = document.createElement('input');
            keyInput.type = 'text';
            keyInput.className = 'form-control';
            keyInput.placeholder = 'Custom Key';
            keyInput.addEventListener('input', function() {
                // Validate key on input
                const validation = validateKey(this.value);
                if (!validation.isValid) {
                    this.classList.add('is-invalid');
                    if (!this.nextElementSibling) {
                        const feedback = document.createElement('div');
                        feedback.className = 'invalid-feedback';
                        keyCell.appendChild(feedback);
                    }
                    this.nextElementSibling.textContent = validation.error;
                } else {
                    this.classList.remove('is-invalid');
                    if (this.nextElementSibling) {
                        this.nextElementSibling.textContent = '';
                    }
                }
            });
            keyCell.appendChild(keyInput);
        } else {
            keyCell.textContent = key;
        }

        if (allowedValues) {
            const select = document.createElement('select');
            select.className = 'form-control';
            select.name = key;
            if (isRequired) select.required = true;

            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = `Select ${key}`;
            select.appendChild(defaultOption);

            allowedValues.forEach(val => {
                const option = document.createElement('option');
                option.value = val;
                option.textContent = val;
                if (val === value) option.selected = true;
                select.appendChild(option);
            });
            valueCell.appendChild(select);
        } else {
            const input = document.createElement('input');
            input.type = key === 'population' || key === 'area_km2' ? 'number' : 'text';
            input.className = 'form-control';
            input.name = key;
            input.value = value;
            if (isRequired) input.required = true;
            input.addEventListener('input', function() {
                // Validate value on input
                const validation = validateValue(this.value, key === 'population' || key === 'area_km2' ? 'number' : 'text');
                if (!validation.isValid) {
                    this.classList.add('is-invalid');
                    if (!this.nextElementSibling) {
                        const feedback = document.createElement('div');
                        feedback.className = 'invalid-feedback';
                        valueCell.appendChild(feedback);
                    }
                    this.nextElementSibling.textContent = validation.error;
                } else {
                    this.classList.remove('is-invalid');
                    if (this.nextElementSibling) {
                        this.nextElementSibling.textContent = '';
                    }
                }
            });
            valueCell.appendChild(input);
        }

        if (!isRequired) {
            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.className = 'btn btn-danger btn-sm';
            removeBtn.textContent = 'Remove';
            removeBtn.onclick = () => {
                row.remove();
                updateOptionalFieldSelect();
            };
            actionCell.appendChild(removeBtn);
        }

        row.appendChild(keyCell);
        row.appendChild(valueCell);
        row.appendChild(actionCell);
        return row;
    }

    function getExistingKeys() {
        const keys = new Set();
        tagsTable.querySelectorAll('tr').forEach(row => {
            const keyElement = row.querySelector('td:first-child');
            const key = keyElement.textContent.trim() || keyElement.querySelector('input')?.value?.trim();
            if (key) {
                keys.add(key);
            }
        });
        return Array.from(keys);
    }

    function validateAndGetTags() {
        const tags = {};
        const errors = [];
        const existingKeys = new Set();

        // Add type
        const selectedType = typeSelect.value?.trim();
        if (!selectedType) {
            errors.push("Please select an area type");
            return { isValid: false, errors };
        }
        tags.type = selectedType;

        // Validate required fields first
        if (areaTypeRequirements[selectedType]) {
            for (const [key, requirements] of Object.entries(areaTypeRequirements[selectedType])) {
                if (requirements.required) {
                    const input = tagsTable.querySelector(`[name="${key}"]`);
                    const value = input?.value?.trim();
                    if (!value) {
                        errors.push(`Required field "${key}" is missing or empty`);
                    }
                }
            }
        }

        // Validate all fields
        tagsTable.querySelectorAll('tr').forEach(row => {
            const keyElement = row.querySelector('td:first-child');
            let keyInput = keyElement.querySelector('input');
            let key = keyElement.textContent.trim();
            
            // Handle custom key input
            if (keyInput) {
                key = keyInput.value?.trim() || '';
            }

            const valueElement = row.querySelector('td:nth-child(2)');
            const valueInput = valueElement.querySelector('input, select');
            let value = valueInput?.value?.trim() || '';

            // Skip if both key and value are empty
            if (!key && !value) {
                return;
            }

            // Validate key
            const keyValidation = validateKey(key);
            if (!keyValidation.isValid) {
                errors.push(`Invalid key "${key}": ${keyValidation.error}`);
                return;
            }

            key = keyValidation.key; // Use the validated and trimmed key

            // Check for duplicate keys
            if (existingKeys.has(key)) {
                errors.push(`Duplicate key: ${key}`);
                return;
            }

            existingKeys.add(key);

            // Validate value
            const requirements = areaTypeRequirements[selectedType]?.[key] || { type: 'text' };
            const valueValidation = validateValue(value, requirements.type, requirements.allowed_values);

            if (!valueValidation.isValid) {
                errors.push(`${key}: ${valueValidation.error}`);
                return;
            }

            value = valueValidation.value; // Use the validated and trimmed value

            // Only add valid key-value pairs
            tags[key] = value;
        });

        // Add GeoJSON if present
        if (currentGeoJson) {
            tags.geo_json = currentGeoJson;
        }

        return {
            isValid: errors.length === 0,
            errors,
            tags
        };
    }

    // Rest of the code remains the same...
    [Previous implementation of updateFields, addOptionalField, updateOptionalFieldSelect, addCustomField functions]

    function submitForm() {
        const validation = validateAndGetTags();
        if (!validation.isValid) {
            showToast('Error', validation.errors.join('\n'), 'error');
            return;
        }

        // Remove any empty or whitespace-only keys before submission
        const cleanedTags = {};
        for (const [key, value] of Object.entries(validation.tags)) {
            const trimmedKey = key.trim();
            const trimmedValue = String(value).trim();
            if (trimmedKey && trimmedValue) {
                cleanedTags[trimmedKey] = trimmedValue;
            }
        }

        fetch('/add_area', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(cleanedTags)
        }).then(response => response.json())
        .then(data => {
            if (data.error) {
                showToast('Error', data.error.message, 'error');
                console.error('Server error:', data.error);
            } else {
                showToast('Success', 'Area added successfully', 'success');
                setTimeout(() => {
                    window.location.href = '/select_area';
                }, 2000);
            }
        }).catch(error => {
            showToast('Error', 'An unexpected error occurred', 'error');
            console.error('Fetch error:', error);
        });
    }

    // Event Listeners
    typeSelect.addEventListener('change', updateFields);
    addOptionalFieldBtn.addEventListener('click', addOptionalField);
    addCustomFieldBtn.addEventListener('click', addCustomField);

    submitAreaBtn.addEventListener('click', function(e) {
        e.preventDefault();
        showToast('Confirm', 'Are you sure you want to add this area?', 'warning', {
            confirmButtonText: 'Yes, add it',
            cancelButtonText: 'Cancel',
            onConfirm: () => {
                submitForm();
            }
        });
    });

    // Initial field update
    updateFields();
});
</script>

<style>
    #map {
        height: 400px;
        width: 100%;
        margin-bottom: 20px;
        border: 1px solid #ccc;
        border-radius: 4px;
    }

    .tag-value-cell {
        max-width: 300px;
        word-wrap: break-word;
    }
    
    .tag-value-content,
    .tag-input,
    .tag-select {
        width: 100%;
        min-height: 38px;
    }
    
    .tag-value-content {
        padding: 6px 12px;
        border: 1px solid transparent;
    }
    
    .tag-input {
        resize: vertical;
    }

    #geojson-input {
        font-family: monospace;
    }

    .invalid-feedback {
        display: block;
        width: 100%;
        margin-top: .25rem;
        font-size: 80%;
        color: #dc3545;
    }
</style>
{% endblock %}
